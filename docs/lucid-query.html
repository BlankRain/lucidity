<html>
  <head>
    <meta content=\"chrome=1\" http-equiv=\"X-UA-Compatible\" />
    <meta charset=\"utf-8\" /><meta content=\"width=device-width, initial-scale=1, user-scalable=no\" name=\"viewport\" />
    <link rel="icon" href="favicon.ico" type="image/x-icon" />
    <title>query - intuitive search for code</title>
    <script src="js/highlight.min.js"></script>
    <style>
      body {
  padding:50px;
  font:14px/1.5 Helvetica, Arial, sans-serif;
  color:#777;
  font-weight:300;
}

h1, h2, h3, h4, h5, h6 {
  color:#222;
  margin:0 0 20px;
}

p, ul, ol, table, pre, dl {
  margin:0 0 20px;
}

h1, h2, h3 {
  line-height:1.1;
}

h1 {
  font-size:28px;
}

h2 {
  color:#393939;
}

h4, h5, h6 {
  color:#494949;
  margin:0;
}

header h4{
  margin: 10 0 0 0px;
}

a {
  color:#3c3;
  font-weight:400;
  text-decoration:none;
}

a small {
  font-size:11px;
  color:#777;
  margin-top:-0.6em;
  display:block;
}

.wrapper {
  width:860px;
  margin:0 auto;
}

.figure div.img {
  text-align: center;
  border-radius: 5px;
  border: 1px solid #ddd;
  padding: 10px;
}

blockquote {
  border-left:1px solid #e5e5e5;
  margin:0;
  padding:0 0 0 20px;
  font-style:italic;
}

code, pre {
  font-family:Monaco, Bitstream Vera Sans Mono, Lucida Console, Terminal;
  color:#333;
  font-size:12px;
}

pre {
  padding:8px 15px;
  background: #fff;  
  border-radius:5px;
  border:1px solid #e5e5e5;
  overflow-x: auto;
}

table {
  width:100%;
  border-collapse:collapse;
}

th, td {
  text-align:left;
  padding:5px 10px;
  border-bottom:1px solid #e5e5e5;
}

dt {
  color:#444;
  font-weight:700;
}

th {
  color:#444;
}

img {
  max-width:100%;
}

header {
  width:250px;
  float:left;
}

header ul {
  list-style:none;
  height:40px;
  padding:0;
  
  background: #eee;
  background: -moz-linear-gradient(top, #f8f8f8 0%, #dddddd 100%);
  background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#f8f8f8), color-stop(100%,#dddddd));
  background: -webkit-linear-gradient(top, #f8f8f8 0%,#dddddd 100%);
  background: -o-linear-gradient(top, #f8f8f8 0%,#dddddd 100%);
  background: -ms-linear-gradient(top, #f8f8f8 0%,#dddddd 100%);
  background: linear-gradient(top, #f8f8f8 0%,#dddddd 100%);
  
  border-radius:5px;
  border:1px solid #d2d2d2;
  box-shadow:inset #fff 0 1px 0, inset rgba(0,0,0,0.03) 0 -1px 0;
}

header li {
  width:89px;
  float:left;
  border-right:1px solid #d2d2d2;
  height:40px;
}

header ul a {
  line-height:1;
  font-size:11px;
  color:#999;
  display:block;
  text-align:center;
  padding-top:6px;
  height:40px;
}

header.top {
  position: fixed;
  top: -2px;
  right:5%;
  width:auto;
}

strong {
  font-weight:700;
}

header ul li + li {
  width:88px;
  border-left:1px solid #fff;
}

header ul li + li + li {
  border-right:none;
  width:89px;
}

header ul a strong {
  font-size:14px;
  display:block;
  color:#222;
}

section {
  margin-left:250px;
  padding-bottom:50px;
}

small {
  font-size:11px;
}

hr {
  border:0;
  background:#e5e5e5;
  height:1px;
  margin:0 0 20px;
}

footer {
  width:250px;
  float:left;
  position:fixed;
  bottom:50px;
}

header div.heading {
  display:none;
}


@media print, screen and (max-width: 960px) {
  
  div.wrapper {
    width:auto;
    margin:0;
  }
  
  header, section, footer {
    float:none;
    position:static;
    width:auto;
  }
  
  header div.heading {
    display:block;
  }
    
  section div.heading {
    display:none;
  }
  
  section {
    border:1px solid #e5e5e5;
    border-width:1px 0;
    padding:20px 0;
    margin:0 0 20px;
  }
  
  header a small {
    display:inline;
  }
  
  header ul {
    position:absolute;
    right:0px;
    top:0px;
    height: auto;
  }
}

@media print, screen and (max-width: 720px) {
  body {
    word-wrap:break-word;
  }
  
  header {
    padding:0;
  }
  
  header ul, header p.view {
    height: auto;
  }
  
  header.top{
    position: absolute;
  }
  
  pre, code {
    word-wrap:normal;
  }
}

@media print, screen and (max-width: 480px) {
  body {
    padding:15px;
  }
  
  header ul {
    display:none;
  }
}

@media print {
  body {
    padding:0.4in;
    font-size:12pt;
    color:#444;
  }
}

      .highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold; } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kn { font-weight: bold } /* Keyword.Namespace */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */

.type-csharp .highlight .k { color: #0000FF }
.type-csharp .highlight .kt { color: #0000FF }
.type-csharp .highlight .nf { color: #000000; font-weight: normal }
.type-csharp .highlight .nc { color: #2B91AF }
.type-csharp .highlight .nn { color: #000000 }
.type-csharp .highlight .s { color: #A31515 }
.type-csharp .highlight .sc { color: #A31515 }

      /*

Qt Creator light color scheme

*/


.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #ffffff;
}

.hljs,
.hljs-subst,
.hljs-tag,
.hljs-title {
  color: #000000;
}

.hljs-strong,
.hljs-emphasis {
  color: #000000;
}

.hljs-bullet,
.hljs-quote,
.hljs-number,
.hljs-regexp,
.hljs-literal {
  color: #000080;
}

.hljs-code
.hljs-selector-class {
  color: #800080;
}

.hljs-emphasis,
.hljs-stronge,
.hljs-type {
  font-style: italic;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-function,
.hljs-section,
.hljs-symbol,
.hljs-name {
  color: #808000;
}

.hljs-attribute {
  color: #800000;
}

.hljs-variable,
.hljs-params,
.hljs-class .hljs-title {
  color: #0055AF;
}

.hljs-string,
.hljs-selector-id,
.hljs-selector-attr,
.hljs-selector-pseudo,
.hljs-type,
.hljs-built_in,
.hljs-builtin-name,
.hljs-template-tag,
.hljs-template-variable,
.hljs-addition,
.hljs-link {
  color: #008000;
}

.hljs-comment,
.hljs-meta,
.hljs-deletion {
  color: #008000;
}
    </style>
  </head>
    
  <body>

    <header class="top">
      <ul><li><a href="index.html">home</a></li><li><a href="lucid-core.html">core</a></li><li><a href="lucid-mind.html">mind</a></li><li><a href="lucid-publish.html">publish</a></li><li><a href="lucid-query.html">query</a></li><li><a href="lucid-space.html">space</a></li><li><a href="lucid-test.html">test</a></li></ul>
    </header>
    <header>      
      <div class="heading">
        <h1>query</h1>
        <h3>intuitive search for code</h3>
        <hr/>
        <div class=\"info\">
          <h5>Author: Chris Zheng<b>&nbsp;&nbsp;<a href="mailto:z@caudate.me">(z@caudate.me)</a></b></h5>
          <h5>Date: 28 September 2016</h5>
          <h5>Repository: <a href="https://www.github.com/tahto/lucidity">https://www.github.com/tahto/lucidity</a></h5>
          <h5>Version: 1.2.0</h5>
        </div>
        <br/>
        <hr/>
      </div>
      <h4><a href="#introduction">1 &nbsp; Introduction</a></h4><h5>&nbsp;&nbsp;<i><a href="#installation">1.1 &nbsp; Installation</a></i></h5><h4><a href="#usage">2 &nbsp; Usage</a></h4><h5>&nbsp;&nbsp;<i><a href="#basics">2.1 &nbsp; Basics</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#path">2.2 &nbsp; Path</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#representation">2.3 &nbsp; Representation</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#cursors">2.4 &nbsp; Cursors</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#fine-grain-control">2.5 &nbsp; Fine Grain Control</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#pattern-matching">2.6 &nbsp; Pattern Matching</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#insertion">2.7 &nbsp; Insertion</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#deletion">2.8 &nbsp; Deletion</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#optional-matches">2.9 &nbsp; Optional Matches</a></i></h5><h4><a href="#utilities">3 &nbsp; Utilities</a></h4><h5>&nbsp;&nbsp;<i><a href="#traverse">3.1 &nbsp; traverse</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#match">3.2 &nbsp; match</a></i></h5><h4><a href="#match-element">4 &nbsp; Match Element</a></h4><h5>&nbsp;&nbsp;<i><a href="#fn">4.1 &nbsp; :fn</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#is">4.2 &nbsp; :is</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#form">4.3 &nbsp; :form</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#or">4.4 &nbsp; :or</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#and">4.5 &nbsp; :and</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#equal">4.6 &nbsp; :equal</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#type">4.7 &nbsp; :type</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#meta">4.8 &nbsp; :meta</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#pattern">4.9 &nbsp; :pattern</a></i></h5><h4><a href="#match-position">5 &nbsp; Match Position</a></h4><h5>&nbsp;&nbsp;<i><a href="#parent">5.1 &nbsp; :parent</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#child">5.2 &nbsp; :child</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#first">5.3 &nbsp; :first</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#last">5.4 &nbsp; :last</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#nth">5.5 &nbsp; :nth</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#nth-left">5.6 &nbsp; :nth-left</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#nth-right">5.7 &nbsp; :nth-right</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#nth-ancestor">5.8 &nbsp; :nth-ancestor</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#nth-contains">5.9 &nbsp; :nth-contains</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#ancestor">5.10 &nbsp; :ancestor</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#contains">5.11 &nbsp; :contains</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#sibling">5.12 &nbsp; :sibling</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#left">5.13 &nbsp; :left</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#right">5.14 &nbsp; :right</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#left-of">5.15 &nbsp; :left-of</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#right-of">5.16 &nbsp; :right-of</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#left-most">5.17 &nbsp; :left-most</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#right-most">5.18 &nbsp; :right-most</a></i></h5>
      <br/>
      <br/>
    </header>
    
    <div class="content">
      <section>
        <div class="heading">
          <h1>query</h1>
          <h3>intuitive search for code</h3>
          <hr/>
          <div class=\"info\">
            <h5>Author: Chris Zheng<b>&nbsp;&nbsp;<a href="mailto:z@caudate.me">(z@caudate.me)</a></b></h5>
            <h5>Date: 28 September 2016</h5>
            <h5>Repository: <a href="https://www.github.com/tahto/lucidity">https://www.github.com/tahto/lucidity</a></h5>
            <h5>Version: 1.2.0</h5>
          </div>
          <br/>
          <hr/>
        </div>
        <div><a name="introduction"></a><h2><b>1 &nbsp;&nbsp; Introduction</b></h2></div><div><p><code>lucid.query</code> makes it easy for querying and manipulation of clojure source code through an <code>xpath</code>/<code>css</code>-inspired syntax. This library was originally developed as <a href='https://github.com/zcaudate/hara/jai'>jai</a>.</p><ul><li>to simplify traversal and manipulation of source code</li><li>to provide higher level abstractions on top of <a href='https://github.com/xsc/rewrite-clj'>rewrite-clj</a></li><li>to leverage <a href='https://github.com/clojure/core.match'>core.match</a>'s pattern matching for a more declarative syntax</li></ul></div><div><a name="installation"></a><h3>1.1 &nbsp;&nbsp; Installation</h3></div><div><p>Add to <code>project.clj</code> dependencies:</p></div><div><pre><code class="clojure">[tahto/lucid.query &quot;1.2.0&quot;]</code></pre></div><div><p>All functionality is in the <code>lucid.query</code> namespace:</p></div><div><pre><code class="clojure">(use 'lucid.query)</code></pre></div><div><a name="usage"></a><h2><b>2 &nbsp;&nbsp; Usage</b></h2></div><div><p>We first define a code fragment to query on. The library currently works with strings and files.</p></div><div><pre><code class="clojure">(def fragment {:string &quot;(defn hello [] (println &#92;&quot;hello&#92;&quot;))&#92;n
                        (defn world [] (if true (prn &#92;&quot;world&#92;&quot;)))&quot;})</code></pre></div><div><a name="basics"></a><h3>2.1 &nbsp;&nbsp; Basics</h3></div><div><p>Find all the <code>defn</code> forms:</p></div><div><pre><code class="clojure">($ fragment [defn])
=&gt; '[(defn hello [] (println &quot;hello&quot;))
     (defn world [] (if true (prn &quot;world&quot;)))]</code></pre></div><div><p>Find all the <code>if</code> forms</p></div><div><pre><code class="clojure">($ fragment [if])
=&gt; '((if true (prn &quot;world&quot;)))</code></pre></div><div><a name="path"></a><h3>2.2 &nbsp;&nbsp; Path</h3></div><div><p>Find all the <code>defn</code> forms that contain an <code>if</code> form directly below it:</p></div><div><pre><code class="clojure">($ fragment [defn if])
=&gt; '[(defn world [] (if true (prn &quot;world&quot;)))]</code></pre></div><div><p>Find all the <code>defn</code> forms that contains a <code>prn</code> form anywhere in its body</p></div><div><pre><code class="clojure">($ fragment [defn :* prn])
=&gt; '[(defn world [] (if true (prn &quot;world&quot;)))]</code></pre></div><div><p>Depth searching at specific levels can also be done, the following code performs a search for <code>prn</code> at the second and third level forms below the <code>defn</code>:</p></div><div><pre><code class="clojure">($ fragment [defn :2 prn])
=&gt; '[(defn world [] (if true (prn &quot;world&quot;)))]
  
($ fragment [defn :3 prn])
=&gt; '[]</code></pre></div><div><a name="representation"></a><h3>2.3 &nbsp;&nbsp; Representation</h3></div><div><p>Instead of returning an s-expression, we can also return other represetations through specifying the <code>:return</code> value on the code. The options are <code>:zipper</code>, <code>:sexpr</code> or <code>:string</code>.</p></div><div><p>By default, querying returns a <code>:sexpr</code> representation</p></div><div><pre><code class="clojure">($ (assoc fragment :return :sexpr) [defn :* prn])
=&gt; '[(defn world [] (if true (prn &quot;world&quot;)))]</code></pre></div><div><p>String representations are useful for directly writing to file</p></div><div><pre><code class="clojure">($ fragment [defn :* prn] {:return :string})
=&gt; [&quot;(defn world [] (if true (prn &#92;&quot;world&#92;&quot;)))&quot;]</code></pre></div><div><p>If more manipulation is needed, then returning a zipper allows composablity with rewrite-clj</p></div><div><pre><code class="clojure">(-&gt;&gt; ($ fragment [defn :* prn] {:return :zipper})
     (map z/sexpr))
=&gt; '[(defn world [] (if true (prn &quot;world&quot;)))]</code></pre></div><div><a name="cursors"></a><h3>2.4 &nbsp;&nbsp; Cursors</h3></div><div><p>It is not very useful just selecting top-level forms. We need a way to move between the sections. This is where cursors come into picture. We can use <code>|</code> to set access to selected forms. For example, we can grab the entire top level form like this:</p></div><div><pre><code class="clojure">($ fragment [defn println])
=&gt; '[(defn hello [] (println &quot;hello&quot;))]</code></pre></div><div><p>But usually, the more common scenario is that we wish to perform a particular action on the <code>&#40;println ...&#41;</code> form. This is accessible by adding <code>&quot;|&quot;</code> in front of the <code>println</code> symbol:</p></div><div><pre><code class="clojure">($ fragment [defn | println])
=&gt; '[(println &quot;hello&quot;)]</code></pre></div><div><p>We can see how the cursor works by drilling down into our code fragment:</p></div><div><pre><code class="clojure">($ fragment [defn if prn])
=&gt; '[(defn world [] (if true (prn &quot;world&quot;)))]
  
($ fragment [| defn if prn])
=&gt; '[(defn world [] (if true (prn &quot;world&quot;)))]
  
($ fragment [defn | if prn])
=&gt; '[(if true (prn &quot;world&quot;))]
  
($ fragment [defn if | prn])
=&gt; '[(prn &quot;world&quot;)]</code></pre></div><div><a name="fine-grain-control"></a><h3>2.5 &nbsp;&nbsp; Fine Grain Control</h3></div><div><p>It is not enough that we can walk to a particular form, we have to be able to control the place within the form that we wish to traverse to. </p></div><div><pre><code class="clojure">($ fragment [defn (if | _ &amp; _)])
=&gt; '[true]
  
($ fragment [defn (if _ | _)])
=&gt; '[(prn &quot;world&quot;)]
  
($ fragment [defn if (prn | _)])
=&gt; '[&quot;world&quot;]</code></pre></div><div><a name="pattern-matching"></a><h3>2.6 &nbsp;&nbsp; Pattern Matching</h3></div><div><p>We can also use a pattern expressed using a list. Defining a pattern allows matched elements to be expressed more intuitively:</p></div><div><pre><code class="clojure">($ fragment [(defn &amp; _)])
=&gt; '[(defn hello [] (println &quot;hello&quot;))
     (defn world [] (if true (prn &quot;world&quot;)))]
  
($ fragment [(defn hello &amp; _)])
=&gt; '[(defn hello [] (println &quot;hello&quot;))]</code></pre></div><div><p>A pattern can have nestings:</p></div><div><pre><code class="clojure">($ fragment [(defn world [] (if &amp; _))])
=&gt; '[(defn world [] (if true (prn &quot;world&quot;)))]</code></pre></div><div><p>If functions are needed, the symbols can be tagged with the a meta <code>&#94;:%</code></p></div><div><pre><code class="clojure">($ fragment [(defn world ^:% vector? ^:% list?)])
=&gt; '[(defn world [] (if true (prn &quot;world&quot;)))]</code></pre></div><div><p>The queries are declarative and should be quite intuitive to use</p></div><div><pre><code class="clojure">($ fragment [(_ _ _ (if ^:% true? &amp; _))])
=&gt; '[(defn world [] (if true (prn &quot;world&quot;)))]</code></pre></div><div><a name="insertion"></a><h3>2.7 &nbsp;&nbsp; Insertion</h3></div><div><p>We can additionally insert elements by tagging with the <code>&#94;:+</code> meta:</p></div><div><pre><code class="clojure">($ fragment [(defn world _ ^:+ (prn &quot;hello&quot;) &amp; _)])
=&gt; '[(defn world [] (prn &quot;hello&quot;) (if true (prn &quot;world&quot;)))]</code></pre></div><div><p>There are some values that do not allow metas tags (<code>strings</code>, <code>keywords</code> and <code>number</code>), in this case the workaround is to use the <code>&#94;:%+</code> meta and write the object as an expression to be evaluated. Note the writing <code>:%+</code> is the equivalent of writing <code>&#94;{:% true :+ true}</code></p></div><div><pre><code class="clojure">($ fragment [(defn world _ (if true (prn ^:%+ (keyword &quot;hello&quot;) _)))])
=&gt; '[(defn world [] (if true (prn :hello &quot;world&quot;)))]</code></pre></div><div><p>Insertions also work seamlessly with cursors:</p></div><div><pre><code class="clojure">($ fragment [(defn world _ (if true | (prn ^:%+ (long 2) _)))])
=&gt; '[(prn 2 &quot;world&quot;)]</code></pre></div><div><a name="deletion"></a><h3>2.8 &nbsp;&nbsp; Deletion</h3></div><div><p>We can delete values by using the <code>&#94;:-</code> meta tag. When used on the code fragment, we can see that the function has been mangled as the first two elements have been deleted:</p></div><div><pre><code class="clojure">($ fragment [(defn ^:- world  ^:- _ &amp; _)])
=&gt; '[(defn (if true (prn &quot;world&quot;)))]</code></pre></div><div><p>Entire forms can be marked for deletion:</p></div><div><pre><code class="clojure">($ fragment [(defn world _ ^:- (if &amp; _))])
=&gt; '[(defn world [])]</code></pre></div><div><p>Deletions and insertions work quite well together. For example, below shows the replacement of the function name from <code>world</code> to <code>world2</code>:</p></div><div><pre><code class="clojure">($ fragment [(defn ^:- world _ ^:+ world2 &amp; _)])
=&gt; '[(defn [] world2 (if true (prn &quot;world&quot;)))]</code></pre></div><div><a name="optional-matches"></a><h3>2.9 &nbsp;&nbsp; Optional Matches</h3></div><div><p>There are certain use cases when source code has optional parameters such as a docstring or a meta map.</p></div><div><pre><code class="clojure">($ fragment [(defn ^:% symbol? ^:%?- string? ^:%?- map? ^:% vector? &amp; _)])
=&gt; '[(defn hello [] (println &quot;hello&quot;))
     (defn world [] (if true (prn &quot;world&quot;)))]</code></pre></div><div><p>We can use optional matches to clean up certain elements within the form, such as being able to remove docstrings and meta maps if they exist.</p></div><div><pre><code class="clojure">($ {:string &quot;(defn add &#92;&quot;adding numbers&#92;&quot; {:added &#92;&quot;0.1&#92;&quot;} [x y] (+ x y))&quot;}
   [(defn ^:% symbol? ^:%?- string? ^:%?- map? ^:% vector? &amp; _)]
   {:return :string})
=&gt; [&quot;(defn add [x y] (+ x y))&quot;]</code></pre></div><div><a name="utilities"></a><h2><b>3 &nbsp;&nbsp; Utilities</b></h2></div><div><p>These utilities are specially designed to work with <code>rewrite-clj</code>;</p></div><div><pre><code class="clojure">(use rewrite-clj.zip :as z)</code></pre></div><div><a name="traverse"></a><h3>3.1 &nbsp;&nbsp; traverse</h3></div><div><p>While the <code>$</code> macro is provided for global searches within a file, <code>traverse</code> is provided to work with the zipper library for traversal/manipulation of a form.</p></div><div><pre><code class="clojure">(-&gt; (z/of-string &quot;(defn add &#92;&quot;adding numbers&#92;&quot; {:added &#92;&quot;0.1&#92;&quot;} [x y] (+ x y))&quot;)
    (traverse '(defn ^:% symbol? ^:%?- string? ^:%?- map? ^:% vector? | &amp; _))
    (z/insert-left '(prn &quot;add&quot;))
    (z/up)
    (z/sexpr))
=&gt; '(defn add [x y] (prn &quot;add&quot;) (+ x y))</code></pre></div><div><p><code>traverse</code> can also be given a function as the third argument. This will perform some action on the location given by the cursor and then jump out again:</p></div><div><pre><code class="clojure">(-&gt; (z/of-string &quot;(defn add &#92;&quot;adding numbers&#92;&quot; {:added &#92;&quot;0.1&#92;&quot;} [x y] (+ x y))&quot;)
    (traverse '(defn ^:% symbol? ^:%?- string? ^:%?- map? ^:% vector? | &amp; _)
              (fn [zloc] (z/insert-left zloc '(prn &quot;add&quot;))))
    (z/sexpr))
=&gt; '(defn add [x y] (prn &quot;add&quot;) (+ x y))</code></pre></div><div><p><code>traverse</code> works with metas as well, which is harder to work with using just <code>rewrite-clj</code></p></div><div><pre><code class="clojure">(-&gt; (z/of-string &quot;(defn add [x y] ^{:text 0} (+ (+ x 1) y 1))&quot;)
    (traverse '(defn _ _ (+ (+ | x 1) y 1))
              (fn [zloc] (z/insert-left zloc '(prn &quot;add&quot;))))
    (z/sexpr))
=&gt; '(defn add [x y] (+ (+ (prn &quot;add&quot;) x 1) y 1))</code></pre></div><div><a name="match"></a><h3>3.2 &nbsp;&nbsp; match</h3></div><div><p>a map-based syntax is provided for matching:</p></div><div><pre><code class="clojure">(-&gt; (z/of-string &quot;(if true (+ 1 2) (+ 1 1))&quot;)
    (match 'if))
=&gt; true
  
(-&gt; (z/of-string &quot;(if true (+ 1 2) (+ 1 1))&quot;)
    (match {:form 'if}))
=&gt; true
  
(-&gt; (z/of-string &quot;(if true (+ 1 2) (+ 1 1))&quot;)
    (match {:is list?}))
=&gt; true
  
(-&gt; (z/of-string &quot;(if true (+ 1 2) (+ 1 1))&quot;)
    (match {:child {:is true}}))
=&gt; true
  
(-&gt; (z/of-string &quot;(if true (+ 1 2) (+ 1 1))&quot;)
    (match {:child {:form '+}}))
=&gt; true</code></pre></div><div><a name="match-element"></a><h2><b>4 &nbsp;&nbsp; Match Element</b></h2></div><div><p>There are many options for matches:   </p><ul><li><code>:fn</code>           match on checking function</li><li><code>:is</code>           match on value or checking function</li><li><code>:or</code>           match two options, done using a set</li><li><code>:equal</code>        match on equivalence</li><li><code>:type</code>         match on <code>rewrite-clj</code> type</li><li><code>:meta</code>         match on meta tag</li><li><code>:form</code>         match on first element of a form</li><li><code>:pattern</code>      match on a pattern</li><li><code>:code</code>         match on code</li></ul></div><div><a name="fn"></a><h3>4.1 &nbsp;&nbsp; :fn</h3></div><div><p>The most general match, takes a predicate dispatching on a zipper location</p></div><div><pre><code class="clojure">(-&gt; (z/of-string &quot;(if true (+ 1 2) (+ 1 1))&quot;)
    (match {:fn (fn [zloc] (= :list (z/tag zloc)))}))
=&gt; true</code></pre></div><div><a name="is"></a><h3>4.2 &nbsp;&nbsp; :is</h3></div><div><p>The most general match, takes a value or a function</p></div><div><pre><code class="clojure">(-&gt; (z/of-string &quot;(if true (+ 1 2) (+ 1 1))&quot;)
    (match {:child {:is true}}))
=&gt; true
  
(-&gt; (z/of-string &quot;(if true (+ 1 2) (+ 1 1))&quot;)
    (match {:child {:is (fn [x] (instance? Boolean x))}}))
=&gt; true</code></pre></div><div><a name="form"></a><h3>4.3 &nbsp;&nbsp; :form</h3></div><div><p>By default, a symbol is evaluated as a <code>:form</code>'</p></div><div><pre><code class="clojure">(-&gt; (z/of-string &quot;(if true (+ 1 2) (+ 1 1))&quot;)
    (match 'if))
=&gt; true</code></pre></div><div><p>It can also be expressed explicitly:</p></div><div><pre><code class="clojure">(-&gt; (z/of-string &quot;(if true (+ 1 2) (+ 1 1))&quot;)
    (match '{:form if}))
=&gt; true</code></pre></div><div><a name="or"></a><h3>4.4 &nbsp;&nbsp; :or</h3></div><div><p>or style matching done using set notation</p></div><div><pre><code class="clojure">(-&gt; (z/of-string &quot;(if true (+ 1 2) (+ 1 1))&quot;)
    (match '#{{:form if} {:form defn}}))
=&gt; true
  
(-&gt; (z/of-string &quot;(if true (+ 1 2) (+ 1 1))&quot;)
    (match '#{if defn}))
=&gt; true</code></pre></div><div><p>if need arises to match a set, use the <code>&#94;&amp;</code> meta tag</p></div><div><pre><code class="clojure">(-&gt; (z/of-string &quot;(if #{:a :b :c} (+ 1 2) (+ 1 1))&quot;)
    (match {:child {:is '^&amp; #{:a :b :c}}}))
=&gt; true</code></pre></div><div><a name="and"></a><h3>4.5 &nbsp;&nbsp; :and</h3></div><div><p>similar usage to :or except that vector notation is used:</p></div><div><pre><code class="clojure">(-&gt; (z/of-string &quot;(if true (+ 1 2) (+ 1 1))&quot;)
    (match '[if defn]))
=&gt; false
  
(-&gt; (z/of-string &quot;(if true (+ 1 2) (+ 1 1))&quot;)
    (match '[if {:contains 1}]))
=&gt; true</code></pre></div><div><a name="equal"></a><h3>4.6 &nbsp;&nbsp; :equal</h3></div><div><p>matches sets, vectors and maps as is</p></div><div><pre><code class="clojure">(-&gt; (z/of-string &quot;(if #{:a :b :c} (+ 1 2) (+ 1 1))&quot;)
    (match {:child {:equal #{:a :b :c}}}))
=&gt; true
  
(-&gt; (z/of-string &quot;(if {:a 1 :b 2} (+ 1 2) (+ 1 1))&quot;)
    (match {:child {:equal {:a 1 :b 2}}}))
=&gt; true</code></pre></div><div><a name="type"></a><h3>4.7 &nbsp;&nbsp; :type</h3></div><div><p>predicate on the rewrite-clj reader type</p></div><div><pre><code class="clojure">(-&gt; (z/of-string &quot;(if true (+ 1 2) (+ 1 1))&quot;)
    (match {:type :list}))
=&gt; true
  
(-&gt; (z/of-string &quot;(if true (+ 1 2) (+ 1 1))&quot;)
    (match {:child {:type :token}}))
=&gt; true</code></pre></div><div><a name="meta"></a><h3>4.8 &nbsp;&nbsp; :meta</h3></div><div><p>matches the meta on a location</p></div><div><pre><code class="clojure">(-&gt; (z/down (z/of-string &quot;^:a (+ 1 1)&quot;))
    (match {:meta :a}))
=&gt; true
  
(-&gt; (z/down (z/of-string &quot;^{:a true} (+ 1 1)&quot;))
    (match {:meta {:a true}}))
=&gt; true</code></pre></div><div><a name="pattern"></a><h3>4.9 &nbsp;&nbsp; :pattern</h3></div><div><p>pattern matches are done automatically with a list</p></div><div><pre><code class="clojure">(-&gt; (z/of-string &quot;(if true (+ 1 2) (+ 1 1))&quot;)
    (match '(if true &amp; _)))
=&gt; true</code></pre></div><div><p>but they can be made more explicit:</p></div><div><pre><code class="clojure">(-&gt; (z/of-string &quot;(if true (+ 1 2) (+ 1 1))&quot;)
    (match {:pattern '(if true &amp; _)}))
=&gt; true</code></pre></div><div><a name="match-position"></a><h2><b>5 &nbsp;&nbsp; Match Position</b></h2></div><div><p>The positional options for matches are:</p><ul><li><code>:parent</code>       match on direct parent of element</li><li><code>:child</code>        match on any child of element</li><li><code>:first</code>        match on first child of element</li><li><code>:last</code>         match on last child of element</li><li><code>:nth</code>          match on nth child of element</li><li><code>:nth-left</code>     match on nth-sibling to the left of element</li><li><code>:nth-right</code>    match on nth-sibling to the right of element</li><li><code>:nth-ancestor</code> match on the ancestor that is n levels higher</li><li><code>:nth-contains</code> match on any contained element that is n levels lower</li><li><code>:ancestor</code>     match on any ancestor</li><li><code>:contains</code>     match on any contained element</li><li><code>:sibling</code>      match on any sibling</li><li><code>:left</code>         match on node directly to left</li><li><code>:right</code>        match on node directly to right</li><li><code>:left-of</code>      match on node to left</li><li><code>:right-of</code>     match on node to right</li><li><code>:left-most</code>    match is element is the left-most element</li><li><code>:right-most</code>   match is element is the right-most element</li></ul></div><div><a name="parent"></a><h3>5.1 &nbsp;&nbsp; :parent</h3></div><div><p>matches on the parent form</p></div><div><pre><code class="clojure">(-&gt; (z/of-string &quot;(if true (+ 1 2) (+ 1 1))&quot;)
    (z/down)
    (z/right)
    (match {:parent 'if}))
=&gt; true</code></pre></div><div><a name="child"></a><h3>5.2 &nbsp;&nbsp; :child</h3></div><div><p>matches on any of the child forms</p></div><div><pre><code class="clojure">(-&gt; (z/of-string &quot;(if true (+ 1 2) (+ 1 1))&quot;)
    (match {:child '(+ _ 2)}))
=&gt; true</code></pre></div><div><a name="first"></a><h3>5.3 &nbsp;&nbsp; :first</h3></div><div><p>matches on the first child, can also be a vector</p></div><div><pre><code class="clojure">(-&gt; (z/of-string &quot;(if [1 2 3] (+ 1 2) (+ 1 1))&quot;)
    (match {:child {:first '+}}))
=&gt; true
  
(-&gt; (z/of-string &quot;(if [1 2 3] (+ 1 2) (+ 1 1))&quot;)
    (match {:child {:first 1}}))
=&gt; true</code></pre></div><div><a name="last"></a><h3>5.4 &nbsp;&nbsp; :last</h3></div><div><p>matches on the last child element</p></div><div><pre><code class="clojure">(-&gt; (z/of-string &quot;(if [1 2 3] (+ 1 2) (+ 1 1))&quot;)
    (match {:child {:last 3}}))
=&gt; true
  
(-&gt; (z/of-string &quot;(if [1 2 3] (+ 1 2) (+ 1 1))&quot;)
    (match {:child {:last 1}}))
=&gt; true</code></pre></div><div><a name="nth"></a><h3>5.5 &nbsp;&nbsp; :nth</h3></div><div><p>matches the nth child</p></div><div><pre><code class="clojure">(-&gt; (z/of-string &quot;(if [1 2 3] (+ 1 2) (+ 1 1))&quot;)
    (match {:nth [1 {:equal [1 2 3]}]}))
=&gt; true</code></pre></div><div><a name="nth-left"></a><h3>5.6 &nbsp;&nbsp; :nth-left</h3></div><div><p>matches the nth sibling to the left</p></div><div><pre><code class="clojure">(-&gt; (z/of-string &quot;(if [1 2 3] (+ 1 2) (+ 1 1))&quot;)
    (z/down)
    (z/rightmost)
    (match {:nth-left [2 {:equal [1 2 3]}]}))
=&gt; true</code></pre></div><div><a name="nth-right"></a><h3>5.7 &nbsp;&nbsp; :nth-right</h3></div><div><p>matches the nth sibling to the right</p></div><div><pre><code class="clojure">(-&gt; (z/of-string &quot;(if [1 2 3] (+ 1 2) (+ 1 1))&quot;)
    (z/down)
    (match {:nth-right [1 {:equal [1 2 3]}]}))
=&gt; true</code></pre></div><div><a name="nth-ancestor"></a><h3>5.8 &nbsp;&nbsp; :nth-ancestor</h3></div><div><p>matches the nth ancestor in the hierarchy</p></div><div><pre><code class="clojure">(-&gt; (z/of-string &quot;(if [1 2 3] (+ 1 2) (+ 1 1))&quot;)
    (z/down)
    (z/right)
    (z/down)
    (match {:nth-ancestor [2 {:form 'if}]}))
=&gt; true</code></pre></div><div><a name="nth-contains"></a><h3>5.9 &nbsp;&nbsp; :nth-contains</h3></div><div><p>matches the nth level children</p></div><div><pre><code class="clojure">(-&gt; (z/of-string &quot;(if [1 2 3] (+ 1 2) (+ 1 1))&quot;)
    (match {:nth-contains [2 {:is 3}]}))
=&gt; true</code></pre></div><div><a name="ancestor"></a><h3>5.10 &nbsp;&nbsp; :ancestor</h3></div><div><p>matches any ancestor</p></div><div><pre><code class="clojure">(-&gt; (z/of-string &quot;(if [1 2 3] (+ 1 2) (+ 1 1))&quot;)
    (z/down)
    (z/right)
    (z/down)
    (match {:ancestor 'if}))
=&gt; true</code></pre></div><div><a name="contains"></a><h3>5.11 &nbsp;&nbsp; :contains</h3></div><div><p>matches the any subelement contained by the element</p></div><div><pre><code class="clojure">(-&gt; (z/of-string &quot;(if [1 2 3] (+ 1 2) (+ 1 1))&quot;)
    (match {:contains 3}))
=&gt; true</code></pre></div><div><a name="sibling"></a><h3>5.12 &nbsp;&nbsp; :sibling</h3></div><div><p>matches any sibling</p></div><div><pre><code class="clojure">(-&gt; (z/of-string &quot;(if [1 2 3] (+ 1 2) (+ 1 1))&quot;)
    (z/down)
    (match {:sibling {:form '+}}))
=&gt; true</code></pre></div><div><a name="left"></a><h3>5.13 &nbsp;&nbsp; :left</h3></div><div><p>matches element to the left</p></div><div><pre><code class="clojure">(-&gt; (z/of-string &quot;(if [1 2 3] (+ 1 2) (+ 1 1))&quot;)
    (z/down)
    (z/right)
    (match {:left {:is 'if}}))
=&gt; true</code></pre></div><div><a name="right"></a><h3>5.14 &nbsp;&nbsp; :right</h3></div><div><p>matches element to the right</p></div><div><pre><code class="clojure">(-&gt; (z/of-string &quot;(if [1 2 3] (+ 1 2) (+ 1 1))&quot;)
    (z/down)
    (match {:right {:is [1 2 3]}}))
=&gt; true</code></pre></div><div><a name="left-of"></a><h3>5.15 &nbsp;&nbsp; :left-of</h3></div><div><p>matches any element to the left</p></div><div><pre><code class="clojure">(-&gt; (z/of-string &quot;(if [1 2 3] (+ 1 2) (+ 1 1))&quot;)
    (z/down)
    (z/rightmost)
    (match {:left-of {:is [1 2 3]}}))
=&gt; true</code></pre></div><div><a name="right-of"></a><h3>5.16 &nbsp;&nbsp; :right-of</h3></div><div><p>matches any element to the right</p></div><div><pre><code class="clojure">(-&gt; (z/of-string &quot;(if [1 2 3] (+ 1 2) (+ 1 1))&quot;)
    (z/down)
    (match {:right-of '(+ 1 1)}))
=&gt; true</code></pre></div><div><a name="left-most"></a><h3>5.17 &nbsp;&nbsp; :left-most</h3></div><div><p>is the left-most element</p></div><div><pre><code class="clojure">(-&gt; (z/of-string &quot;(if [1 2 3] (+ 1 2) (+ 1 1))&quot;)
    (z/down)
    (match {:left-most true}))
=&gt; true</code></pre></div><div><a name="right-most"></a><h3>5.18 &nbsp;&nbsp; :right-most</h3></div><div><p>is the right-most element</p></div><div><pre><code class="clojure">(-&gt; (z/of-string &quot;(if [1 2 3] (+ 1 2) (+ 1 1))&quot;)
    (z/down)
    (z/rightmost)
    (match {:right-most true}))
=&gt; true</code></pre></div>
      </section>
    </div>
  </body>
  <script type="text/javascript">
    var metas = document.getElementsByTagName('meta');
var i;
if (navigator.userAgent.match(/iPhone/i)) {
  for (i=0; i<metas.length; i++) {
    if (metas[i].name == "viewport") {
      metas[i].content = "width=device-width, minimum-scale=1.0, maximum-scale=1.0";
    }
  }
  document.addEventListener("gesturestart", gestureStart, false);
}
function gestureStart() {
  for (i=0; i<metas.length; i++) {
    if (metas[i].name == "viewport") {
      metas[i].content = "width=device-width, minimum-scale=0.25, maximum-scale=1.6";
    }
  }
}
    
    hljs.registerLanguage("clojure",function(e){var t={"builtin-name":"def defonce cond apply if-not if-let if not not= = < > <= >= == + / * - rem quot neg? pos? delay? symbol? keyword? true? false? integer? empty? coll? list? set? ifn? fn? associative? sequential? sorted? counted? reversible? number? decimal? class? distinct? isa? float? rational? reduced? ratio? odd? even? char? seq? vector? string? map? nil? contains? zero? instance? not-every? not-any? libspec? -> ->> .. . inc compare do dotimes mapcat take remove take-while drop letfn drop-last take-last drop-while while intern condp case reduced cycle split-at split-with repeat replicate iterate range merge zipmap declare line-seq sort comparator sort-by dorun doall nthnext nthrest partition eval doseq await await-for let agent atom send send-off release-pending-sends add-watch mapv filterv remove-watch agent-error restart-agent set-error-handler error-handler set-error-mode! error-mode shutdown-agents quote var fn loop recur throw try monitor-enter monitor-exit defmacro defn defn- macroexpand macroexpand-1 for dosync and or when when-not when-let comp juxt partial sequence memoize constantly complement identity assert peek pop doto proxy defstruct first rest cons defprotocol cast coll deftype defrecord last butlast sigs reify second ffirst fnext nfirst nnext defmulti defmethod meta with-meta ns in-ns create-ns import refer keys select-keys vals key val rseq name namespace promise into transient persistent! conj! assoc! dissoc! pop! disj! use class type num float double short byte boolean bigint biginteger bigdec print-method print-dup throw-if printf format load compile get-in update-in pr pr-on newline flush read slurp read-line subvec with-open memfn time re-find re-groups rand-int rand mod locking assert-valid-fdecl alias resolve ref deref refset swap! reset! set-validator! compare-and-set! alter-meta! reset-meta! commute get-validator alter ref-set ref-history-count ref-min-history ref-max-history ensure sync io! new next conj set! to-array future future-call into-array aset gen-class reduce map filter find empty hash-map hash-set sorted-map sorted-map-by sorted-set sorted-set-by vec vector seq flatten reverse assoc dissoc list disj get union difference intersection extend extend-type extend-protocol int nth delay count concat chunk chunk-buffer chunk-append chunk-first chunk-rest max min dec unchecked-inc-int unchecked-inc unchecked-dec-inc unchecked-dec unchecked-negate unchecked-add-int unchecked-add unchecked-subtract-int unchecked-subtract chunk-next chunk-cons chunked-seq? prn vary-meta lazy-seq spread list* str find-keyword keyword symbol gensym force rationalize"},r="a-zA-Z_\\-!.?+*=<>&#'",n="["+r+"]["+r+"0-9/;:]*",a="[-+]?\\d+(\\.\\d+)?",o={b:n,r:0},s={cN:"number",b:a,r:0},i=e.inherit(e.QSM,{i:null}),c=e.C(";","$",{r:0}),d={cN:"literal",b:/\b(true|false|nil)\b/},l={b:"[\\[\\{]",e:"[\\]\\}]"},m={cN:"comment",b:"\\^"+n},p=e.C("\\^\\{","\\}"),u={cN:"symbol",b:"[:]{1,2}"+n},f={b:"\\(",e:"\\)"},h={eW:!0,r:0},y={k:t,l:n,cN:"name",b:n,starts:h},b=[f,i,m,p,c,u,l,s,d,o];return f.c=[e.C("comment",""),y,h],h.c=b,l.c=b,{aliases:["clj"],i:/\S/,c:[f,i,m,p,c,u,l,s,d]}});
    hljs.initHighlightingOnLoad();
  </script>
  </html>